"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const sprightly_1 = require("./sprightly");
jest.mock("fs", () => {
    const dir = {
        "my-name": `my name is {{ myName }}.\n{{> ../his-name }}`,
        "../his-name": `his name is {{ hisName }}`,
        nested: "my name is {{ name.first }} {{ name.last }}",
        "array-indexing": "my name is {{ name.0 }} {{ name.1 }}",
        "nested-indexing": "{{ property.nested.0.anotherProperty.1 }}",
        "yielding-non-strings-and-numbers": "{{ object }}, {{ array }}, {{ bool }}, {{ null }}, {{ undefined }}, {{ function }}",
        "not-found-referenced-component": "{{> ../not-found }}",
    };
    return {
        readFileSync: jest.fn((filePath) => {
            if (filePath in dir) {
                return dir[filePath];
            }
            throw new Error("file not found");
        }),
        existsSync: (filePath) => filePath in dir,
    };
});
jest.mock("path", () => {
    return Object.assign(Object.assign({}, jest.requireActual("path")), { isAbsolute: () => true, dirname: () => "", normalize: (filePath) => filePath });
});
test("good first test", () => __awaiter(void 0, void 0, void 0, function* () {
    const doc = yield (0, sprightly_1.sprightlyAsync)("my-name", {
        myName: "Obada",
        hisName: "Osid",
    });
    expect(doc).toMatchInlineSnapshot(`
    "my name is Obada.
    his name is Osid"
  `);
}));
test("if wrong arguments types are passed, then an error should be thrown", () => __awaiter(void 0, void 0, void 0, function* () {
    yield expect((0, sprightly_1.sprightlyAsync)([], {})).rejects.toThrowErrorMatchingInlineSnapshot(`"Entry point must be a string"`);
    yield expect((0, sprightly_1.sprightlyAsync)("my-name", new Map())).rejects.toThrowErrorMatchingInlineSnapshot(`"Data must be an object"`);
    yield expect((0, sprightly_1.sprightlyAsync)("my-name", {}, 123)).rejects.toThrowErrorMatchingInlineSnapshot(`"Options must be an object or undefined"`);
}));
test("if key doesn't exist, then the resolved value should be `keyFallback`'s default value whcih is empty string", () => __awaiter(void 0, void 0, void 0, function* () {
    const doc = yield (0, sprightly_1.sprightlyAsync)("my-name", { hisName: "Osid" });
    expect(doc).toMatchInlineSnapshot(`
    "my name is .
    his name is Osid"
  `);
}));
test("if key doesn't exist and the `keyFallback` is set, then the resolved value should be the value set to `keyFallback`", () => __awaiter(void 0, void 0, void 0, function* () {
    const doc = yield (0, sprightly_1.sprightlyAsync)("my-name", { hisName: "Osid" }, { keyFallback: "Obada" });
    expect(doc).toMatchInlineSnapshot(`
    "my name is Obada.
    his name is Osid"
  `);
}));
test("if key doesn't exist and the `throwOnKeyNotfound` is set to true, then an error should be thrown", () => __awaiter(void 0, void 0, void 0, function* () {
    yield expect((0, sprightly_1.sprightlyAsync)("my-name", { hisName: "Osid" }, { throwOnKeyNotfound: true })).rejects.toMatchInlineSnapshot(`[Error: Key "myName" was not found at "my-name"]`);
}));
test("nested properties are resolved correctly", () => __awaiter(void 0, void 0, void 0, function* () {
    const doc = yield (0, sprightly_1.sprightlyAsync)("nested", {
        name: { first: "Obada", last: "Khalili" },
    });
    expect(doc).toMatchInlineSnapshot(`"my name is Obada Khalili"`);
}));
test("array indexing is resolved correctly", () => __awaiter(void 0, void 0, void 0, function* () {
    const doc = yield (0, sprightly_1.sprightlyAsync)("array-indexing", {
        name: ["Obada", "Khalili"],
    });
    expect(doc).toMatchInlineSnapshot(`"my name is Obada Khalili"`);
}));
test("yielded values other than strings and numbers are stringified", () => __awaiter(void 0, void 0, void 0, function* () {
    const doc = yield (0, sprightly_1.sprightlyAsync)("yielding-non-strings-and-numbers", {
        object: { a: 1 },
        array: [1, 2, {}],
        bool: true,
        null: null,
        undefined: undefined,
        function: (a, b) => a + b,
    });
    expect(doc).toMatchInlineSnapshot(`"[object Object], 1,2,[object Object], true, null, undefined, (a, b) => a + b"`);
}));
test("throws if entry point not found", () => __awaiter(void 0, void 0, void 0, function* () {
    yield expect((0, sprightly_1.sprightlyAsync)("not-found", {})).rejects.toMatchInlineSnapshot(`[Error: Entry point "not-found" does not exist]`);
}));
test("throws if component not found", () => __awaiter(void 0, void 0, void 0, function* () {
    yield expect((0, sprightly_1.sprightlyAsync)("not-found-referenced-component", {})).rejects.toMatchInlineSnapshot(`[Error: Component "../not-found" was not found at "not-found-referenced-component"]`);
}));
test("deep nested properties and array indexing are resolved correctly", () => __awaiter(void 0, void 0, void 0, function* () {
    const doc = yield (0, sprightly_1.sprightlyAsync)("nested-indexing", {
        property: {
            nested: [{ anotherProperty: ["Obada", "Khalili"] }],
        },
    });
    expect(doc).toMatchInlineSnapshot(`"Khalili"`);
}));
describe("cache tests", () => {
    test("expect file to be read twice if cache is disabled", () => __awaiter(void 0, void 0, void 0, function* () {
        const readFilesCount = jest.mocked(fs_1.default).readFileSync.mock.calls.length;
        const options = { cache: false };
        yield (0, sprightly_1.sprightlyAsync)("../his-name", {}, options);
        expect(fs_1.default.readFileSync).toHaveBeenCalledTimes(readFilesCount + 1);
        yield (0, sprightly_1.sprightlyAsync)("../his-name", {}, options);
        expect(fs_1.default.readFileSync).toHaveBeenCalledTimes(readFilesCount + 2);
    }));
    test("expect file to not be read twice if cache is enabled", () => __awaiter(void 0, void 0, void 0, function* () {
        const readFilesCount = jest.mocked(fs_1.default).readFileSync.mock.calls.length;
        const options = { cache: true };
        yield (0, sprightly_1.sprightlyAsync)("../his-name", {}, options);
        expect(fs_1.default.readFileSync).toHaveBeenCalledTimes(readFilesCount + 1);
        yield (0, sprightly_1.sprightlyAsync)("../his-name", {}, options);
        expect(fs_1.default.readFileSync).toHaveBeenCalledTimes(readFilesCount + 1);
    }));
});
